// -*- c++ -*-
//
// Copyright 2025 SST Contributors
//
// MultiCorePE.cc: çœŸæ­£çš„å¤šæ ¸è„‰å†²ç¥ç»ç½‘ç»œå¤„ç†å•å…ƒå®ç°æ–‡ä»¶
//

#include <sst/core/sst_config.h>
#include "MultiCorePE.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <functional>

using namespace SST;
using namespace SST::SnnDL;

// ===== MultiCorePE ä¸»ç»„ä»¶å®ç° =====

MultiCorePE::MultiCorePE(ComponentId_t id, Params& params) : Component(id) {
    // åˆå§‹åŒ–è¾“å‡ºå¯¹è±¡
    int verbose_level = params.find<int>("verbose", 0);
    output_ = new Output("MultiCorePE[@p:@l]: ", verbose_level, 0, Output::STDOUT);
    
    output_->verbose(CALL_INFO, 1, 0, "ğŸš€ åˆå§‹åŒ–MultiCorePEç»„ä»¶ (ID: %" PRIu64 ")\n", id);
    
    // è¯»å–åŸºç¡€é…ç½®å‚æ•°
    num_cores_ = params.find<int>("num_cores", 4);
    neurons_per_core_ = params.find<int>("neurons_per_core", 64);
    total_neurons_ = num_cores_ * neurons_per_core_;
    node_id_ = params.find<int>("node_id", 0);
    verbose_ = verbose_level;
    weights_file_ = params.find<std::string>("weights_file", "");
    enable_numa_ = params.find<bool>("enable_numa", true);
    
    // ç¥ç»å…ƒå‚æ•°
    v_thresh_ = params.find<float>("v_thresh", 1.0f);
    v_reset_ = params.find<float>("v_reset", 0.0f);
    v_rest_ = params.find<float>("v_rest", 0.0f);
    tau_mem_ = params.find<float>("tau_mem", 20.0f);
    t_ref_ = params.find<int>("t_ref", 2);
    
    // æµ‹è¯•æµé‡å‚æ•°
    enable_test_traffic_ = params.find<bool>("enable_test_traffic", false);
    test_target_node_ = params.find<int>("test_target_node", 0);
    test_period_ = params.find<int>("test_period", 100);
    test_spikes_per_burst_ = params.find<int>("test_spikes_per_burst", 4);
    test_weight_ = params.find<float>("test_weight", 0.2f);
    
    output_->verbose(CALL_INFO, 2, 0, 
        "ğŸ”§ å¤šæ ¸PEé…ç½®: cores=%d, neurons_per_core=%d, total_neurons=%d, node_id=%d\n",
        num_cores_, neurons_per_core_, total_neurons_, node_id_);
    
    output_->verbose(CALL_INFO, 2, 0, 
        "ğŸ§  ç¥ç»å…ƒå‚æ•°: v_thresh=%.3f, v_reset=%.3f, v_rest=%.3f, tau_mem=%.1fms, t_ref=%d\n",
        v_thresh_, v_reset_, v_rest_, tau_mem_, t_ref_);
    
    // éªŒè¯å‚æ•°åˆç†æ€§
    if (num_cores_ <= 0 || num_cores_ > 64) {
        output_->fatal(CALL_INFO, -1, "âŒ é”™è¯¯: num_coreså¿…é¡»åœ¨1-64ä¹‹é—´ï¼Œå½“å‰å€¼=%d\n", num_cores_);
    }
    if (neurons_per_core_ <= 0 || neurons_per_core_ > 1024) {
        output_->fatal(CALL_INFO, -1, "âŒ é”™è¯¯: neurons_per_coreå¿…é¡»åœ¨1-1024ä¹‹é—´ï¼Œå½“å‰å€¼=%d\n", neurons_per_core_);
    }
    
    // åˆå§‹åŒ–æ—¶é’Ÿè®¡æ•°å™¨
    current_cycle_ = 0;
    test_cycle_counter_ = 0;
    
    // åˆå§‹åŒ–å¤„ç†å•å…ƒçŠ¶æ€è¿½è¸ª
    unit_states_.resize(num_cores_);
    for (int i = 0; i < num_cores_; i++) {
        unit_states_[i].unit_id = i;
        unit_states_[i].neuron_id_start = i * neurons_per_core_;
        unit_states_[i].neuron_count = neurons_per_core_;
        unit_states_[i].is_active = false;
        unit_states_[i].spikes_processed = 0;
        unit_states_[i].neurons_fired = 0;
        unit_states_[i].utilization = 0.0;
    }
    
    // åˆå§‹åŒ–ç»„ä»¶æŒ‡é’ˆä¸ºç©º
    l2_cache_ = nullptr;
    memory_interface_ = nullptr;
    external_nic_ = nullptr;
    internal_ring_ = nullptr;
    controller_ = nullptr;
    clock_handler_ = nullptr;
    
    // åˆå§‹åŒ–ç«¯å£æŒ‡é’ˆä¸ºç©º
    external_spike_input_link_ = nullptr;
    external_spike_output_link_ = nullptr;
    mem_link_ = nullptr;
    
    output_->verbose(CALL_INFO, 1, 0, "âœ… MultiCorePEåŸºç¡€åˆå§‹åŒ–å®Œæˆ\n");
}

MultiCorePE::~MultiCorePE() {
    output_->verbose(CALL_INFO, 1, 0, "ğŸ—‘ï¸ é”€æ¯MultiCorePEç»„ä»¶\n");
    
    // æ¸…ç†å¤„ç†å•å…ƒ
    for (auto* unit : processing_units_) {
        delete unit;
    }
    processing_units_.clear();
    
    // æ¸…ç†å†…éƒ¨ç»„ä»¶
    delete internal_ring_;
    delete controller_;
    delete output_;
    
    // æ¸…ç†å¤–éƒ¨è„‰å†²é˜Ÿåˆ—
    while (!external_spike_queue_.empty()) {
        delete external_spike_queue_.front();
        external_spike_queue_.pop();
    }
    
    // æ¸…ç†æŒ‚èµ·çš„å†…å­˜è¯·æ±‚
    for (auto& pair : pending_memory_requests_) {
        delete pair.second;
    }
    pending_memory_requests_.clear();
}

void MultiCorePE::init(unsigned int phase) {
    output_->verbose(CALL_INFO, 2, 0, "ğŸ”„ MultiCorePEåˆå§‹åŒ–é˜¶æ®µ %d\n", phase);
    
    if (phase == 0) {
        // é˜¶æ®µ0ï¼šåˆå§‹åŒ–åŸºç¡€ç»„ä»¶å’Œç«¯å£
        
        // é…ç½®æ—¶é’Ÿ
        std::string clock_freq = "1GHz";  // é»˜è®¤æ—¶é’Ÿé¢‘ç‡
        clock_handler_ = new Clock::Handler<MultiCorePE>(this, &MultiCorePE::clockTick);
        registerClock(clock_freq, clock_handler_);
        
        output_->verbose(CALL_INFO, 2, 0, "â° é…ç½®æ—¶é’Ÿé¢‘ç‡: %s\n", clock_freq.c_str());
        
        // åˆå§‹åŒ–ç»Ÿè®¡æ”¶é›†
        initializeStatistics();
        
        // åˆå§‹åŒ–ç«¯å£è¿æ¥
        external_spike_input_link_ = configureLink("external_spike_input", 
            new Event::Handler<MultiCorePE>(this, &MultiCorePE::handleExternalSpikeEvent));
        external_spike_output_link_ = configureLink("external_spike_output");
        mem_link_ = configureLink("mem_link");
        
        output_->verbose(CALL_INFO, 2, 0, "ğŸ”— é…ç½®å¤–éƒ¨ç«¯å£è¿æ¥\n");
        
        // åˆå§‹åŒ–å¤„ç†å•å…ƒ
        initializeProcessingUnits();
        
        // åˆå§‹åŒ–å†…éƒ¨äº’è¿
        initializeInternalRing();
        
        // åˆå§‹åŒ–å¤šæ ¸æ§åˆ¶å™¨
        controller_ = new MultiCoreController(this, output_);
        
        output_->verbose(CALL_INFO, 1, 0, "âœ… MultiCorePEé˜¶æ®µ0åˆå§‹åŒ–å®Œæˆ\n");
    }
    else if (phase == 1) {
        // é˜¶æ®µ1ï¼šåŠ è½½æƒé‡å’Œé…ç½®å­ç»„ä»¶
        loadAndDistributeWeights();
        output_->verbose(CALL_INFO, 1, 0, "âœ… MultiCorePEé˜¶æ®µ1åˆå§‹åŒ–å®Œæˆ\n");
    }
}

void MultiCorePE::setup() {
    output_->verbose(CALL_INFO, 1, 0, "ğŸ”§ MultiCorePE setupé˜¶æ®µ\n");
    
    // éªŒè¯æ‰€æœ‰ç»„ä»¶åˆå§‹åŒ–å®Œæˆ
    if (processing_units_.size() != static_cast<size_t>(num_cores_)) {
        output_->fatal(CALL_INFO, -1, "âŒ é”™è¯¯: å¤„ç†å•å…ƒæ•°é‡ä¸åŒ¹é…ï¼ŒæœŸæœ›%dï¼Œå®é™…%zu\n", 
                      num_cores_, processing_units_.size());
    }
    
    if (!internal_ring_) {
        output_->fatal(CALL_INFO, -1, "âŒ é”™è¯¯: å†…éƒ¨äº’è¿æœªåˆå§‹åŒ–\n");
    }
    
    if (!controller_) {
        output_->fatal(CALL_INFO, -1, "âŒ é”™è¯¯: å¤šæ ¸æ§åˆ¶å™¨æœªåˆå§‹åŒ–\n");
    }
    
    // æ‰“å°ç»„ä»¶é…ç½®æ‘˜è¦
    output_->verbose(CALL_INFO, 1, 0, "ğŸ“Š MultiCorePEé…ç½®æ‘˜è¦:\n");
    output_->verbose(CALL_INFO, 1, 0, "   - å¤„ç†å•å…ƒæ•°: %d\n", num_cores_);
    output_->verbose(CALL_INFO, 1, 0, "   - æ¯æ ¸ç¥ç»å…ƒæ•°: %d\n", neurons_per_core_);
    output_->verbose(CALL_INFO, 1, 0, "   - æ€»ç¥ç»å…ƒæ•°: %d\n", total_neurons_);
    output_->verbose(CALL_INFO, 1, 0, "   - èŠ‚ç‚¹ID: %d\n", node_id_);
    output_->verbose(CALL_INFO, 1, 0, "   - NUMAä¼˜åŒ–: %s\n", enable_numa_ ? "å¯ç”¨" : "ç¦ç”¨");
    output_->verbose(CALL_INFO, 1, 0, "   - æµ‹è¯•æµé‡: %s\n", enable_test_traffic_ ? "å¯ç”¨" : "ç¦ç”¨");
    
    output_->verbose(CALL_INFO, 1, 0, "âœ… MultiCorePE setupå®Œæˆ\n");
}

void MultiCorePE::finish() {
    output_->verbose(CALL_INFO, 1, 0, "ğŸ MultiCorePEå®Œæˆä»¿çœŸ\n");
    
    // æ›´æ–°æœ€ç»ˆç»Ÿè®¡ä¿¡æ¯
    updateStatistics();
    
    // æ‰“å°æ€§èƒ½æ‘˜è¦
    output_->verbose(CALL_INFO, 1, 0, "ğŸ“Š MultiCorePEæ€§èƒ½æ‘˜è¦:\n");
    output_->verbose(CALL_INFO, 1, 0, "   - æ€»å‘¨æœŸæ•°: %" PRIu64 "\n", current_cycle_);
    output_->verbose(CALL_INFO, 1, 0, "   - å¤„ç†çš„è„‰å†²æ€»æ•°: %" PRIu64 "\n", 
                    stat_spikes_processed_->getAccumulatedValue());
    output_->verbose(CALL_INFO, 1, 0, "   - å‘æ”¾çš„ç¥ç»å…ƒæ€»æ•°: %" PRIu64 "\n", 
                    stat_neurons_fired_->getAccumulatedValue());
    output_->verbose(CALL_INFO, 1, 0, "   - æ ¸é—´æ¶ˆæ¯æ•°: %" PRIu64 "\n", 
                    stat_inter_core_messages_->getAccumulatedValue());
    output_->verbose(CALL_INFO, 1, 0, "   - å¹³å‡æ ¸å¿ƒåˆ©ç”¨ç‡: %.2f%%\n", 
                    stat_avg_utilization_->getAccumulatedValue());
    
    // æ‰“å°å„å¤„ç†å•å…ƒç»Ÿè®¡
    for (int i = 0; i < num_cores_; i++) {
        const auto& state = unit_states_[i];
        output_->verbose(CALL_INFO, 1, 0, "   å¤„ç†å•å…ƒ%d: è„‰å†²=%" PRIu64 ", å‘æ”¾=%" PRIu64 ", åˆ©ç”¨ç‡=%.2f%%\n",
                        i, state.spikes_processed, state.neurons_fired, state.utilization * 100.0);
    }
    
    output_->verbose(CALL_INFO, 1, 0, "âœ… MultiCorePEç»Ÿè®¡è¾“å‡ºå®Œæˆ\n");
}

bool MultiCorePE::clockTick(Cycle_t current_cycle) {
    current_cycle_ = current_cycle;
    
    // è¯¦ç»†è°ƒè¯•ä¿¡æ¯ï¼ˆä»…åœ¨é«˜è¯¦ç»†åº¦æ—¶è¾“å‡ºï¼‰
    if (verbose_ >= 4 && current_cycle % 1000 == 0) {
        output_->verbose(CALL_INFO, 4, 0, "â° MultiCorePEæ—¶é’Ÿå‘¨æœŸ %" PRIu64 "\n", current_cycle);
    }
    
    // 1. å¤„ç†å¤–éƒ¨è„‰å†²é˜Ÿåˆ—
    while (!external_spike_queue_.empty()) {
        SpikeEvent* spike = external_spike_queue_.front();
        external_spike_queue_.pop();
        
        int target_unit = determineTargetUnit(spike->getDestinationNeuron());
        if (target_unit >= 0 && target_unit < num_cores_) {
            processing_units_[target_unit]->processSpike(spike);
            stat_spikes_processed_->addData(1);
        } else {
            output_->verbose(CALL_INFO, 2, 0, "âš ï¸ ä¸¢å¼ƒæ— æ•ˆç›®æ ‡çš„è„‰å†²: ç¥ç»å…ƒ%d, ç›®æ ‡å•å…ƒ%d\n", 
                           spike->getDestinationNeuron(), target_unit);
            delete spike;
        }
    }
    
    // 2. å¤„ç†å•å…ƒæ—¶é’Ÿæ»´ç­”
    for (int i = 0; i < num_cores_; i++) {
        processing_units_[i]->tick(current_cycle);
        
        // æ›´æ–°å¤„ç†å•å…ƒçŠ¶æ€
        unit_states_[i].spikes_processed = processing_units_[i]->getSpikesProcessed();
        unit_states_[i].neurons_fired = processing_units_[i]->getNeuronsFired();
        unit_states_[i].utilization = processing_units_[i]->getUtilization();
        unit_states_[i].is_active = processing_units_[i]->hasWork();
    }
    
    // 3. å†…éƒ¨äº’è¿æ—¶é’Ÿæ»´ç­”
    if (internal_ring_) {
        internal_ring_->tick();
        
        // å¤„ç†è·¨æ ¸è„‰å†²è·¯ç”±
        handleCrossCoreRouting();
    }
    
    // 4. å¤šæ ¸æ§åˆ¶å™¨æ—¶é’Ÿæ»´ç­”
    if (controller_) {
        controller_->tick();
        
        // æ¯100å‘¨æœŸè¿›è¡Œä¸€æ¬¡è´Ÿè½½å‡è¡¡æ£€æŸ¥
        if (current_cycle % 100 == 0) {
            checkLoadBalance();
        }
    }
    
    // 5. ç”Ÿæˆæµ‹è¯•æµé‡
    if (enable_test_traffic_) {
        generateTestTraffic();
    }
    
    // 6. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ï¼ˆæ¯1000å‘¨æœŸä¸€æ¬¡ï¼‰
    if (current_cycle % 1000 == 0) {
        updateStatistics();
    }
    
    // ç»§ç»­ä»¿çœŸ
    return false;
}

void MultiCorePE::handleExternalSpikeEvent(Event* ev) {
    SpikeEvent* spike = dynamic_cast<SpikeEvent*>(ev);
    if (!spike) {
        output_->verbose(CALL_INFO, 1, 0, "âš ï¸ æ¥æ”¶åˆ°éSpikeEventäº‹ä»¶\n");
        delete ev;
        return;
    }
    
    output_->verbose(CALL_INFO, 3, 0, "ğŸ“¨ æ¥æ”¶å¤–éƒ¨è„‰å†²: æºç¥ç»å…ƒ%d -> ç›®æ ‡ç¥ç»å…ƒ%d, æƒé‡%.3f\n",
                    spike->getSourceNeuron(), spike->getDestinationNeuron(), spike->getWeight());
    
    stat_external_spikes_received_->addData(1);
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°ç¥ç»å…ƒ
    if (isLocalNeuron(spike->getDestinationNeuron())) {
        // æœ¬åœ°è„‰å†²ï¼ŒåŠ å…¥é˜Ÿåˆ—å¤„ç†
        external_spike_queue_.push(spike);
    } else {
        // éæœ¬åœ°è„‰å†²ï¼Œè½¬å‘æˆ–ä¸¢å¼ƒ
        output_->verbose(CALL_INFO, 2, 0, "âš ï¸ ä¸¢å¼ƒéæœ¬åœ°ç›®æ ‡çš„è„‰å†²: ç¥ç»å…ƒ%d\n", 
                       spike->getDestinationNeuron());
        delete spike;
    }
}

void MultiCorePE::handleExternalSpike(SpikeEvent* spike) {
    if (!spike) return;
    
    output_->verbose(CALL_INFO, 3, 0, "ğŸ”„ å¤„ç†å¤–éƒ¨è„‰å†²: ç›®æ ‡ç¥ç»å…ƒ%d\n", spike->getDestinationNeuron());
    
    // å°†è„‰å†²åŠ å…¥å¤–éƒ¨é˜Ÿåˆ—ï¼Œç”±æ—¶é’Ÿå¤„ç†å™¨å¤„ç†
    external_spike_queue_.push(spike);
    stat_external_spikes_received_->addData(1);
}

void MultiCorePE::sendExternalSpike(SpikeEvent* spike) {
    if (!spike || !external_spike_output_link_) return;
    
    output_->verbose(CALL_INFO, 3, 0, "ğŸ“¤ å‘é€å¤–éƒ¨è„‰å†²: æºç¥ç»å…ƒ%d -> ç›®æ ‡ç¥ç»å…ƒ%d\n",
                    spike->getSourceNeuron(), spike->getDestinationNeuron());
    
    external_spike_output_link_->send(spike);
    stat_external_spikes_sent_->addData(1);
}

void MultiCorePE::routeInternalSpike(int src_core, int dst_core, SpikeEvent* spike) {
    if (!spike || !internal_ring_) return;
    
    if (src_core < 0 || src_core >= num_cores_ || dst_core < 0 || dst_core >= num_cores_) {
        output_->verbose(CALL_INFO, 1, 0, "âš ï¸ æ— æ•ˆçš„æ ¸å¿ƒID: src=%d, dst=%d\n", src_core, dst_core);
        delete spike;
        return;
    }
    
    output_->verbose(CALL_INFO, 4, 0, "ğŸ”„ è·¯ç”±å†…éƒ¨è„‰å†²: æ ¸å¿ƒ%d -> æ ¸å¿ƒ%d, ç¥ç»å…ƒ%d\n",
                    src_core, dst_core, spike->getDestinationNeuron());
    
    // åˆ›å»ºå†…éƒ¨æ¶ˆæ¯
    RingMessage msg;
    msg.type = RingMessageType::SPIKE_MESSAGE;
    msg.src_unit = src_core;
    msg.dst_unit = dst_core;
    msg.timestamp = current_cycle_;
    msg.payload.spike_data = spike;
    
    // å‘é€åˆ°å†…éƒ¨ç¯å½¢ç½‘ç»œ
    if (internal_ring_->sendMessage(msg)) {
        stat_inter_core_messages_->addData(1);
    } else {
        output_->verbose(CALL_INFO, 2, 0, "âš ï¸ å†…éƒ¨ç¯å½¢ç½‘ç»œå‘é€å¤±è´¥\n");
        delete spike;
    }
}

int MultiCorePE::determineTargetUnit(int neuron_id) const {
    // å‡è®¾ç¥ç»å…ƒIDæŒ‰ç…§è¿ç»­åˆ†é…ï¼šPE0ç®¡ç†0-63ï¼ŒPE1ç®¡ç†64-127ï¼Œç­‰ç­‰
    int local_neuron_id = neuron_id - (node_id_ * total_neurons_);
    
    if (local_neuron_id < 0 || local_neuron_id >= total_neurons_) {
        return -1;  // éæœ¬MultiCorePEçš„ç¥ç»å…ƒ
    }
    
    int target_unit = local_neuron_id / neurons_per_core_;
    return (target_unit >= 0 && target_unit < num_cores_) ? target_unit : -1;
}

bool MultiCorePE::isLocalNeuron(int neuron_id) const {
    int start_id = node_id_ * total_neurons_;
    int end_id = start_id + total_neurons_;
    return (neuron_id >= start_id && neuron_id < end_id);
}

const ProcessingUnitState& MultiCorePE::getProcessingUnitState(int unit_id) const {
    static ProcessingUnitState empty_state;
    if (unit_id >= 0 && unit_id < num_cores_) {
        return unit_states_[unit_id];
    }
    return empty_state;
}

void MultiCorePE::getStatistics(std::map<std::string, uint64_t>& stats) const {
    stats["total_spikes_processed"] = stat_spikes_processed_->getAccumulatedValue();
    stats["inter_core_messages"] = stat_inter_core_messages_->getAccumulatedValue();
    stats["total_neurons_fired"] = stat_neurons_fired_->getAccumulatedValue();
    stats["external_spikes_sent"] = stat_external_spikes_sent_->getAccumulatedValue();
    stats["external_spikes_received"] = stat_external_spikes_received_->getAccumulatedValue();
    stats["current_cycle"] = current_cycle_;
}

void MultiCorePE::initializeStatistics() {
    output_->verbose(CALL_INFO, 2, 0, "ğŸ“Š åˆå§‹åŒ–ç»Ÿè®¡æ”¶é›†\n");
    
    stat_spikes_processed_ = registerStatistic<uint64_t>("total_spikes_processed");
    stat_inter_core_messages_ = registerStatistic<uint64_t>("inter_core_messages");
    stat_l2_hits_ = registerStatistic<uint64_t>("l2_cache_hits");
    stat_l2_misses_ = registerStatistic<uint64_t>("l2_cache_misses");
    stat_memory_requests_ = registerStatistic<uint64_t>("memory_requests");
    stat_avg_utilization_ = registerStatistic<double>("avg_core_utilization");
    stat_neurons_fired_ = registerStatistic<uint64_t>("total_neurons_fired");
    stat_external_spikes_sent_ = registerStatistic<uint64_t>("external_spikes_sent");
    stat_external_spikes_received_ = registerStatistic<uint64_t>("external_spikes_received");
    
    output_->verbose(CALL_INFO, 2, 0, "âœ… ç»Ÿè®¡æ”¶é›†åˆå§‹åŒ–å®Œæˆ\n");
}

void MultiCorePE::initializeProcessingUnits() {
    output_->verbose(CALL_INFO, 2, 0, "ğŸ”§ åˆå§‹åŒ–%dä¸ªå¤„ç†å•å…ƒ\n", num_cores_);
    
    processing_units_.reserve(num_cores_);
    
    for (int i = 0; i < num_cores_; i++) {
        int neuron_id_start = node_id_ * total_neurons_ + i * neurons_per_core_;
        
        // åˆ›å»ºå¤„ç†å•å…ƒå‚æ•°
        Params unit_params;
        unit_params.insert("unit_id", std::to_string(i));
        unit_params.insert("neuron_id_start", std::to_string(neuron_id_start));
        unit_params.insert("neuron_count", std::to_string(neurons_per_core_));
        unit_params.insert("v_thresh", std::to_string(v_thresh_));
        unit_params.insert("v_reset", std::to_string(v_reset_));
        unit_params.insert("v_rest", std::to_string(v_rest_));
        unit_params.insert("tau_mem", std::to_string(tau_mem_));
        unit_params.insert("t_ref", std::to_string(t_ref_));
        unit_params.insert("verbose", std::to_string(verbose_));
        
        ProcessingUnit* unit = new ProcessingUnit(i, neuron_id_start, neurons_per_core_, 
                                                 this, unit_params);
        processing_units_.push_back(unit);
        
        output_->verbose(CALL_INFO, 3, 0, "   å¤„ç†å•å…ƒ%d: ç¥ç»å…ƒIDèŒƒå›´[%d, %d)\n",
                        i, neuron_id_start, neuron_id_start + neurons_per_core_);
    }
    
    output_->verbose(CALL_INFO, 2, 0, "âœ… å¤„ç†å•å…ƒåˆå§‹åŒ–å®Œæˆ\n");
}

void MultiCorePE::initializeInternalRing() {
    output_->verbose(CALL_INFO, 2, 0, "ğŸ”— åˆå§‹åŒ–å†…éƒ¨ç¯å½¢äº’è¿\n");
    
    int ring_latency = 1;  // 1å‘¨æœŸå»¶è¿Ÿ
    internal_ring_ = new InternalRing(num_cores_, ring_latency, output_);
    
    output_->verbose(CALL_INFO, 2, 0, "âœ… å†…éƒ¨ç¯å½¢äº’è¿åˆå§‹åŒ–å®Œæˆï¼ˆ%dèŠ‚ç‚¹ï¼Œ%då‘¨æœŸå»¶è¿Ÿï¼‰\n", 
                    num_cores_, ring_latency);
}

void MultiCorePE::loadAndDistributeWeights() {
    if (weights_file_.empty()) {
        output_->verbose(CALL_INFO, 2, 0, "âš ï¸ æœªæŒ‡å®šæƒé‡æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤æƒé‡\n");
        return;
    }
    
    output_->verbose(CALL_INFO, 2, 0, "ğŸ“¥ åŠ è½½æƒé‡æ–‡ä»¶: %s\n", weights_file_.c_str());
    
    // TODO: å®ç°æƒé‡åŠ è½½å’Œåˆ†å¸ƒé€»è¾‘
    // è¿™é‡Œåº”è¯¥ä»æ–‡ä»¶åŠ è½½æƒé‡å¹¶åˆ†å‘åˆ°å„ä¸ªå¤„ç†å•å…ƒ
    
    output_->verbose(CALL_INFO, 2, 0, "âœ… æƒé‡åŠ è½½å’Œåˆ†å¸ƒå®Œæˆ\n");
}

void MultiCorePE::updateStatistics() {
    // æ”¶é›†å¤„ç†å•å…ƒç»Ÿè®¡ä¿¡æ¯
    uint64_t total_spikes = 0;
    uint64_t total_fired = 0;
    double total_utilization = 0.0;
    
    for (int i = 0; i < num_cores_; i++) {
        total_spikes += unit_states_[i].spikes_processed;
        total_fired += unit_states_[i].neurons_fired;
        total_utilization += unit_states_[i].utilization;
    }
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    stat_neurons_fired_->addData(total_fired);
    stat_avg_utilization_->addData(total_utilization / num_cores_);
    
    // è¯¦ç»†è°ƒè¯•ä¿¡æ¯
    if (verbose_ >= 3 && current_cycle_ % 10000 == 0) {
        output_->verbose(CALL_INFO, 3, 0, "ğŸ“Š å‘¨æœŸ%" PRIu64 "ç»Ÿè®¡: è„‰å†²=%" PRIu64 ", å‘æ”¾=%" PRIu64 ", åˆ©ç”¨ç‡=%.2f%%\n",
                        current_cycle_, total_spikes, total_fired, (total_utilization / num_cores_) * 100.0);
    }
}

void MultiCorePE::generateTestTraffic() {
    test_cycle_counter_++;
    
    if (test_cycle_counter_ >= static_cast<uint64_t>(test_period_)) {
        test_cycle_counter_ = 0;
        
        output_->verbose(CALL_INFO, 4, 0, "ğŸ”¥ ç”Ÿæˆæµ‹è¯•æµé‡: %dä¸ªè„‰å†²\n", test_spikes_per_burst_);
        
        for (int i = 0; i < test_spikes_per_burst_; i++) {
            // åˆ›å»ºæµ‹è¯•è„‰å†²
            int src_neuron = node_id_ * total_neurons_ + (i % total_neurons_);
            int dst_neuron = test_target_node_ * total_neurons_ + (i % total_neurons_);
            
            SpikeEvent* test_spike = new SpikeEvent(src_neuron, dst_neuron, test_weight_, current_cycle_);
            
            // å‘é€å¤–éƒ¨è„‰å†²
            sendExternalSpike(test_spike);
        }
    }
}

void MultiCorePE::handleCrossCoreRouting() {
    if (!internal_ring_) return;
    
    // æ£€æŸ¥æ¯ä¸ªå¤„ç†å•å…ƒæ˜¯å¦æœ‰è·¨æ ¸æ¶ˆæ¯
    for (int i = 0; i < num_cores_; i++) {
        RingMessage msg;
        if (internal_ring_->receiveMessage(i, msg)) {
            if (msg.type == RingMessageType::SPIKE_MESSAGE && msg.payload.spike_data) {
                // å°†è„‰å†²ä¼ é€’ç»™ç›®æ ‡å¤„ç†å•å…ƒ
                int target_unit = msg.dst_unit;
                if (target_unit >= 0 && target_unit < num_cores_) {
                    processing_units_[target_unit]->processSpike(msg.payload.spike_data);
                    stat_spikes_processed_->addData(1);
                    
                    output_->verbose(CALL_INFO, 4, 0, "ğŸ”„ è·¨æ ¸è„‰å†²è·¯ç”±: æ ¸å¿ƒ%d -> æ ¸å¿ƒ%d\n", 
                                   msg.src_unit, msg.dst_unit);
                } else {
                    output_->verbose(CALL_INFO, 2, 0, "âš ï¸ æ— æ•ˆçš„ç›®æ ‡å•å…ƒ: %d\n", target_unit);
                    delete msg.payload.spike_data;
                }
            }
        }
    }
}

void MultiCorePE::checkLoadBalance() {
    if (!controller_) return;
    
    // è®¡ç®—è´Ÿè½½å·®å¼‚
    double max_util = 0.0, min_util = 1.0;
    for (int i = 0; i < num_cores_; i++) {
        double util = unit_states_[i].utilization;
        max_util = std::max(max_util, util);
        min_util = std::min(min_util, util);
    }
    
    double load_imbalance = max_util - min_util;
    if (load_imbalance > 0.3) {  // 30%è´Ÿè½½å·®å¼‚é˜ˆå€¼
        output_->verbose(CALL_INFO, 3, 0, "âš–ï¸ æ£€æµ‹åˆ°è´Ÿè½½ä¸å‡è¡¡: %.2f%% (æœ€å¤§%.2f%%, æœ€å°%.2f%%)\n",
                        load_imbalance * 100.0, max_util * 100.0, min_util * 100.0);
        
        controller_->balanceLoad();
    }
}

// ===== ProcessingUnit å®ç° =====

ProcessingUnit::ProcessingUnit(int unit_id, int neuron_id_start, int neuron_count, 
                               MultiCorePE* parent, Params& params) 
    : unit_id_(unit_id), neuron_id_start_(neuron_id_start), neuron_count_(neuron_count), parent_pe_(parent) {
    
    // åˆå§‹åŒ–è¾“å‡ºå¯¹è±¡
    int verbose = params.find<int>("verbose", 0);
    output_ = new Output("ProcessingUnit[@p:@l]: ", verbose, 0, Output::STDOUT);
    
    // è¯»å–ç¥ç»å…ƒå‚æ•°
    v_thresh_ = params.find<float>("v_thresh", 1.0f);
    v_reset_ = params.find<float>("v_reset", 0.0f);
    v_rest_ = params.find<float>("v_rest", 0.0f);
    tau_mem_ = params.find<float>("tau_mem", 20.0f);
    t_ref_ = params.find<int>("t_ref", 2);
    
    // åˆå§‹åŒ–ç¥ç»å…ƒçŠ¶æ€
    neuron_states_.resize(neuron_count);
    for (int i = 0; i < neuron_count; i++) {
        neuron_states_[i].v_mem = v_rest_;
        neuron_states_[i].ref_count = 0;
        neuron_states_[i].last_spike_time = 0;
    }
    
    // åˆå§‹åŒ–æƒé‡æ˜ å°„çš„å“ˆå¸Œå‡½æ•°
    weights_ = std::unordered_map<std::pair<int, int>, float, 
                                  std::function<size_t(const std::pair<int, int>&)>>(
        100,  // åˆå§‹bucketæ•°é‡
        [](const std::pair<int, int>& p) -> size_t {
            return std::hash<int>()(p.first) ^ (std::hash<int>()(p.second) << 1);
        }
    );
    
    // åˆå§‹åŒ–ç»Ÿè®¡å˜é‡
    spikes_processed_ = 0;
    neurons_fired_ = 0;
    total_cycles_ = 0;
    active_cycles_ = 0;
    
    output_->verbose(CALL_INFO, 2, 0, "âœ… å¤„ç†å•å…ƒ%dåˆå§‹åŒ–å®Œæˆ: ç¥ç»å…ƒ[%d, %d), å‚æ•°(thresh=%.3f, reset=%.3f, rest=%.3f)\n",
                    unit_id_, neuron_id_start_, neuron_id_start_ + neuron_count_, v_thresh_, v_reset_, v_rest_);
}

ProcessingUnit::~ProcessingUnit() {
    // æ¸…ç†æœ¬åœ°è„‰å†²é˜Ÿåˆ—
    while (!local_spike_queue_.empty()) {
        delete local_spike_queue_.front();
        local_spike_queue_.pop();
    }
    
    // æ¸…ç†è¾“å‡ºè„‰å†²
    for (auto* spike : outgoing_spikes_) {
        delete spike;
    }
    outgoing_spikes_.clear();
    
    delete output_;
}

void ProcessingUnit::processSpike(SpikeEvent* spike) {
    if (!spike) return;
    
    // å°†è„‰å†²åŠ å…¥æœ¬åœ°é˜Ÿåˆ—
    local_spike_queue_.push(spike);
    spikes_processed_++;
    
    output_->verbose(CALL_INFO, 4, 0, "ğŸ“¨ å¤„ç†å•å…ƒ%dæ¥æ”¶è„‰å†²: ç›®æ ‡ç¥ç»å…ƒ%d, æƒé‡%.3f\n",
                    unit_id_, spike->getDestinationNeuron(), spike->getWeight());
}

void ProcessingUnit::tick(Cycle_t cycle) {
    total_cycles_++;
    bool has_activity = false;
    
    // å¤„ç†æœ¬åœ°è„‰å†²é˜Ÿåˆ—
    while (!local_spike_queue_.empty()) {
        SpikeEvent* spike = local_spike_queue_.front();
        local_spike_queue_.pop();
        
        int local_neuron_id = spike->getDestinationNeuron() - neuron_id_start_;
        if (local_neuron_id >= 0 && local_neuron_id < neuron_count_) {
            processSpikeForNeuron(local_neuron_id, spike->getWeight());
            has_activity = true;
        }
        
        delete spike;
    }
    
    // æ›´æ–°ç¥ç»å…ƒçŠ¶æ€
    updateNeuronStates();
    
    // æ£€æŸ¥å¹¶ç”Ÿæˆè¾“å‡ºè„‰å†²
    checkAndGenerateSpikes();
    
    // å‘é€è¾“å‡ºè„‰å†²
    sendOutputSpikes();
    
    if (has_activity || !outgoing_spikes_.empty()) {
        active_cycles_++;
    }
}

bool ProcessingUnit::hasWork() const {
    return !local_spike_queue_.empty() || !outgoing_spikes_.empty() ||
           std::any_of(neuron_states_.begin(), neuron_states_.end(),
                      [](const NeuronState& state) { return state.v_mem > 0.1f; });
}

double ProcessingUnit::getUtilization() const {
    if (total_cycles_ == 0) return 0.0;
    return static_cast<double>(active_cycles_) / static_cast<double>(total_cycles_);
}

void ProcessingUnit::loadWeights(const std::vector<float>& weights, int start_index) {
    // TODO: å®ç°æƒé‡åŠ è½½é€»è¾‘
    output_->verbose(CALL_INFO, 3, 0, "ğŸ“¥ å¤„ç†å•å…ƒ%dåŠ è½½æƒé‡: èµ·å§‹ç´¢å¼•%d, æƒé‡æ•°%zu\n",
                    unit_id_, start_index, weights.size());
}

float ProcessingUnit::getWeight(int pre_neuron, int post_neuron) const {
    auto it = weights_.find(std::make_pair(pre_neuron, post_neuron));
    return (it != weights_.end()) ? it->second : 0.0f;
}

void ProcessingUnit::resetNeuron(int local_neuron_id) {
    if (local_neuron_id >= 0 && local_neuron_id < neuron_count_) {
        neuron_states_[local_neuron_id].v_mem = v_rest_;
        neuron_states_[local_neuron_id].ref_count = 0;
    }
}

float ProcessingUnit::getNeuronVoltage(int local_neuron_id) const {
    if (local_neuron_id >= 0 && local_neuron_id < neuron_count_) {
        return neuron_states_[local_neuron_id].v_mem;
    }
    return 0.0f;
}

void ProcessingUnit::updateNeuronStates() {
    // æ›´æ–°æ‰€æœ‰ç¥ç»å…ƒçš„è†œç”µä½å’Œä¸åº”æœŸ
    for (int i = 0; i < neuron_count_; i++) {
        auto& neuron = neuron_states_[i];
        
        // å¤„ç†ä¸åº”æœŸ
        if (neuron.ref_count > 0) {
            neuron.ref_count--;
            continue;
        }
        
        // è†œç”µä½æ³„æ¼
        if (neuron.v_mem > v_rest_) {
            neuron.v_mem = v_rest_ + (neuron.v_mem - v_rest_) * exp(-1.0f / tau_mem_);
        }
    }
}

void ProcessingUnit::processSpikeForNeuron(int neuron_id, float weight) {
    if (neuron_id < 0 || neuron_id >= neuron_count_) return;
    
    auto& neuron = neuron_states_[neuron_id];
    
    // æ£€æŸ¥æ˜¯å¦åœ¨ä¸åº”æœŸ
    if (neuron.ref_count > 0) return;
    
    // æ·»åŠ æƒé‡åˆ°è†œç”µä½
    neuron.v_mem += weight;
    
    output_->verbose(CALL_INFO, 5, 0, "âš¡ å¤„ç†å•å…ƒ%dç¥ç»å…ƒ%d: v_mem=%.3f (æ·»åŠ æƒé‡%.3f)\n",
                    unit_id_, neuron_id, neuron.v_mem, weight);
}

void ProcessingUnit::checkAndGenerateSpikes() {
    for (int i = 0; i < neuron_count_; i++) {
        auto& neuron = neuron_states_[i];
        
        if (neuron.v_mem >= v_thresh_ && neuron.ref_count == 0) {
            // ç¥ç»å…ƒå‘æ”¾è„‰å†²
            neuron.v_mem = v_reset_;
            neuron.ref_count = t_ref_;
            neuron.last_spike_time = total_cycles_;
            neurons_fired_++;
            
            int global_neuron_id = neuron_id_start_ + i;
            
            output_->verbose(CALL_INFO, 3, 0, "ğŸ”¥ å¤„ç†å•å…ƒ%dç¥ç»å…ƒ%då‘æ”¾è„‰å†²! (å…¨å±€ID=%d)\n",
                           unit_id_, i, global_neuron_id);
            
            // åˆ›å»ºè¾“å‡ºè„‰å†²ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºå‘é€ç»™ç›¸é‚»ç¥ç»å…ƒï¼‰
            int target_neuron = global_neuron_id + 1;
            if (target_neuron < neuron_id_start_ + neuron_count_) {
                SpikeEvent* output_spike = new SpikeEvent(global_neuron_id, target_neuron, 0.5f, total_cycles_);
                outgoing_spikes_.push_back(output_spike);
            }
        }
    }
}

void ProcessingUnit::sendOutputSpikes() {
    for (auto* spike : outgoing_spikes_) {
        // ç¡®å®šç›®æ ‡æ˜¯æœ¬åœ°è¿˜æ˜¯è¿œç¨‹
        int target_unit = parent_pe_->determineTargetUnit(spike->getDestinationNeuron());
        
        if (target_unit == unit_id_) {
            // æœ¬åœ°è¿æ¥ï¼Œç›´æ¥å¤„ç†
            local_spike_queue_.push(spike);
        } else if (target_unit >= 0) {
            // è·¨æ ¸è¿æ¥ï¼Œé€šè¿‡å†…éƒ¨äº’è¿å‘é€
            parent_pe_->routeInternalSpike(unit_id_, target_unit, spike);
        } else {
            // å¤–éƒ¨è¿æ¥ï¼Œé€šè¿‡å¤–éƒ¨æ¥å£å‘é€
            parent_pe_->sendExternalSpike(spike);
        }
    }
    
    outgoing_spikes_.clear();
}

// ===== InternalRing å®ç° =====

InternalRing::InternalRing(int num_nodes, int latency_cycles, SST::Output* output)
    : num_nodes_(num_nodes), latency_cycles_(latency_cycles), output_(output) {
    
    // åˆå§‹åŒ–æ¯ä¸ªèŠ‚ç‚¹çš„è¾“å…¥è¾“å‡ºé˜Ÿåˆ—
    node_input_queues_.resize(num_nodes_);
    node_output_queues_.resize(num_nodes_);
    
    // åˆå§‹åŒ–ç»Ÿè®¡å˜é‡
    total_messages_routed_ = 0;
    total_latency_cycles_ = 0;
    
    output_->verbose(CALL_INFO, 2, 0, "ğŸ”— å†…éƒ¨ç¯å½¢ç½‘ç»œåˆå§‹åŒ–: %dä¸ªèŠ‚ç‚¹, %då‘¨æœŸå»¶è¿Ÿ\n", 
                    num_nodes_, latency_cycles_);
}

InternalRing::~InternalRing() {
    // æ¸…ç†æ‰€æœ‰é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯
    for (int i = 0; i < num_nodes_; i++) {
        while (!node_input_queues_[i].empty()) {
            RingMessage& msg = node_input_queues_[i].front();
            if (msg.type == RingMessageType::SPIKE_MESSAGE && msg.payload.spike_data) {
                delete msg.payload.spike_data;
            }
            node_input_queues_[i].pop();
        }
        
        while (!node_output_queues_[i].empty()) {
            RingMessage& msg = node_output_queues_[i].front();
            if (msg.type == RingMessageType::SPIKE_MESSAGE && msg.payload.spike_data) {
                delete msg.payload.spike_data;
            }
            node_output_queues_[i].pop();
        }
    }
    
    // æ¸…ç†ç¯å½¢ç¼“å†²åŒº
    while (!ring_buffer_.empty()) {
        RingMessage& msg = ring_buffer_.front();
        if (msg.type == RingMessageType::SPIKE_MESSAGE && msg.payload.spike_data) {
            delete msg.payload.spike_data;
        }
        ring_buffer_.pop();
    }
}

bool InternalRing::sendMessage(const RingMessage& msg) {
    if (msg.src_unit < 0 || msg.src_unit >= num_nodes_ || 
        msg.dst_unit < 0 || msg.dst_unit >= num_nodes_) {
        output_->verbose(CALL_INFO, 1, 0, "âš ï¸ å†…éƒ¨ç¯å½¢ç½‘ç»œ: æ— æ•ˆçš„èŠ‚ç‚¹ID (src=%d, dst=%d)\n", 
                       msg.src_unit, msg.dst_unit);
        return false;
    }
    
    // æ£€æŸ¥è¾“å‡ºé˜Ÿåˆ—æ˜¯å¦æœ‰ç©ºé—´
    if (node_output_queues_[msg.src_unit].size() >= 100) {  // é™åˆ¶é˜Ÿåˆ—å¤§å°
        output_->verbose(CALL_INFO, 2, 0, "âš ï¸ å†…éƒ¨ç¯å½¢ç½‘ç»œ: èŠ‚ç‚¹%dè¾“å‡ºé˜Ÿåˆ—å·²æ»¡\n", msg.src_unit);
        return false;
    }
    
    // å°†æ¶ˆæ¯åŠ å…¥æºèŠ‚ç‚¹çš„è¾“å‡ºé˜Ÿåˆ—
    node_output_queues_[msg.src_unit].push(msg);
    
    output_->verbose(CALL_INFO, 4, 0, "ğŸ“¤ å†…éƒ¨ç¯å½¢ç½‘ç»œ: èŠ‚ç‚¹%då‘é€æ¶ˆæ¯åˆ°èŠ‚ç‚¹%d\n", 
                    msg.src_unit, msg.dst_unit);
    
    return true;
}

bool InternalRing::receiveMessage(int node_id, RingMessage& msg) {
    if (node_id < 0 || node_id >= num_nodes_) {
        return false;
    }
    
    if (node_input_queues_[node_id].empty()) {
        return false;
    }
    
    msg = node_input_queues_[node_id].front();
    node_input_queues_[node_id].pop();
    
    output_->verbose(CALL_INFO, 4, 0, "ğŸ“¨ å†…éƒ¨ç¯å½¢ç½‘ç»œ: èŠ‚ç‚¹%dæ¥æ”¶æ¶ˆæ¯\n", node_id);
    
    return true;
}

void InternalRing::tick() {
    // ç®€åŒ–çš„ç¯å½¢ç½‘ç»œå®ç°ï¼šç›´æ¥è·¯ç”±æ¶ˆæ¯
    for (int src = 0; src < num_nodes_; src++) {
        while (!node_output_queues_[src].empty()) {
            RingMessage msg = node_output_queues_[src].front();
            node_output_queues_[src].pop();
            
            routeMessage(msg);
            total_messages_routed_++;
        }
    }
    
    // å¤„ç†ç¯å½¢ç¼“å†²åŒºä¸­çš„å»¶è¿Ÿæ¶ˆæ¯
    std::queue<RingMessage> delayed_messages;
    while (!ring_buffer_.empty()) {
        RingMessage msg = ring_buffer_.front();
        ring_buffer_.pop();
        
        // æ£€æŸ¥å»¶è¿Ÿæ˜¯å¦æ»¡è¶³
        uint64_t current_time = 0;  // è¿™é‡Œç®€åŒ–ï¼Œå®é™…åº”è¯¥è·å–å½“å‰æ—¶é’Ÿ
        if (current_time - msg.timestamp >= static_cast<uint64_t>(latency_cycles_)) {
            // å»¶è¿Ÿæ»¡è¶³ï¼Œå‘é€åˆ°ç›®æ ‡èŠ‚ç‚¹
            node_input_queues_[msg.dst_unit].push(msg);
            total_latency_cycles_ += (current_time - msg.timestamp);
        } else {
            // å»¶è¿Ÿæœªæ»¡è¶³ï¼Œé‡æ–°åŠ å…¥ç¼“å†²åŒº
            delayed_messages.push(msg);
        }
    }
    
    // å°†å»¶è¿Ÿæ¶ˆæ¯é‡æ–°åŠ å…¥ç¼“å†²åŒº
    ring_buffer_ = delayed_messages;
}

bool InternalRing::hasTrafficForNode(int node_id) const {
    if (node_id < 0 || node_id >= num_nodes_) {
        return false;
    }
    return !node_input_queues_[node_id].empty();
}

int InternalRing::getPendingMessageCount() const {
    int total = ring_buffer_.size();
    for (int i = 0; i < num_nodes_; i++) {
        total += node_input_queues_[i].size() + node_output_queues_[i].size();
    }
    return total;
}

double InternalRing::getAverageLatency() const {
    if (total_messages_routed_ == 0) return 0.0;
    return static_cast<double>(total_latency_cycles_) / static_cast<double>(total_messages_routed_);
}

int InternalRing::getNextNode(int current_node) const {
    return (current_node + 1) % num_nodes_;
}

void InternalRing::routeMessage(const RingMessage& msg) {
    if (latency_cycles_ <= 0) {
        // é›¶å»¶è¿Ÿï¼Œç›´æ¥å‘é€
        node_input_queues_[msg.dst_unit].push(msg);
    } else {
        // æœ‰å»¶è¿Ÿï¼ŒåŠ å…¥ç¯å½¢ç¼“å†²åŒº
        ring_buffer_.push(msg);
    }
}

// ===== MultiCoreController å®ç° =====

MultiCoreController::MultiCoreController(MultiCorePE* parent, SST::Output* output)
    : parent_pe_(parent), output_(output) {
    
    // åˆå§‹åŒ–è´Ÿè½½å‡è¡¡çŠ¶æ€
    core_utilization_history_.resize(parent_pe_->num_cores_, 0.0);
    core_work_count_.resize(parent_pe_->num_cores_, 0);
    
    // åˆå§‹åŒ–ç»Ÿè®¡å˜é‡
    total_work_distributed_ = 0;
    load_imbalance_count_ = 0;
    load_balance_threshold_ = 0.2;  // 20%è´Ÿè½½å·®å¼‚é˜ˆå€¼
    
    output_->verbose(CALL_INFO, 2, 0, "âš–ï¸ å¤šæ ¸æ§åˆ¶å™¨åˆå§‹åŒ–: %dä¸ªæ ¸å¿ƒ\n", parent_pe_->num_cores_);
}

MultiCoreController::~MultiCoreController() {
    output_->verbose(CALL_INFO, 2, 0, "ğŸ—‘ï¸ é”€æ¯å¤šæ ¸æ§åˆ¶å™¨\n");
}

void MultiCoreController::scheduleWork() {
    // ç®€å•çš„è½®è¯¢è°ƒåº¦ç­–ç•¥
    // å®é™…å®ç°ä¸­å¯ä»¥æ ¹æ®è´Ÿè½½æƒ…å†µè¿›è¡Œæ™ºèƒ½è°ƒåº¦
    
    static int next_core = 0;
    
    // è½®è¯¢åˆ†é…å·¥ä½œåˆ°ä¸‹ä¸€ä¸ªæ ¸å¿ƒ
    next_core = (next_core + 1) % parent_pe_->num_cores_;
    core_work_count_[next_core]++;
    total_work_distributed_++;
    
    output_->verbose(CALL_INFO, 5, 0, "ğŸ“‹ è°ƒåº¦å·¥ä½œåˆ°æ ¸å¿ƒ%d (æ€»å·¥ä½œé‡%" PRIu64 ")\n", 
                    next_core, total_work_distributed_);
}

void MultiCoreController::balanceLoad() {
    output_->verbose(CALL_INFO, 3, 0, "âš–ï¸ æ‰§è¡Œè´Ÿè½½å‡è¡¡\n");
    
    int most_loaded = findMostLoadedCore();
    int least_loaded = findLeastLoadedCore();
    
    if (most_loaded != least_loaded && most_loaded >= 0 && least_loaded >= 0) {
        double load_diff = core_utilization_history_[most_loaded] - core_utilization_history_[least_loaded];
        
        if (load_diff > load_balance_threshold_) {
            redistributeWork();
            load_imbalance_count_++;
            
            output_->verbose(CALL_INFO, 3, 0, "âš–ï¸ è´Ÿè½½é‡åˆ†å¸ƒ: æ ¸å¿ƒ%d(%.2f%%) -> æ ¸å¿ƒ%d(%.2f%%)\n",
                           most_loaded, core_utilization_history_[most_loaded] * 100.0,
                           least_loaded, core_utilization_history_[least_loaded] * 100.0);
        }
    }
}

void MultiCoreController::tick() {
    // æ¯ä¸ªæ—¶é’Ÿå‘¨æœŸæ›´æ–°æ€§èƒ½è®¡æ•°å™¨
    updatePerformanceCounters();
}

void MultiCoreController::updatePerformanceCounters() {
    // æ›´æ–°æ¯ä¸ªæ ¸å¿ƒçš„åˆ©ç”¨ç‡å†å²
    for (int i = 0; i < parent_pe_->num_cores_; i++) {
        const auto& state = parent_pe_->getProcessingUnitState(i);
        
        // ä½¿ç”¨æŒ‡æ•°ç§»åŠ¨å¹³å‡æ›´æ–°åˆ©ç”¨ç‡å†å²
        double alpha = 0.1;  // å¹³æ»‘å› å­
        core_utilization_history_[i] = alpha * state.utilization + 
                                      (1.0 - alpha) * core_utilization_history_[i];
    }
}

double MultiCoreController::getCoreUtilization(int core_id) const {
    if (core_id >= 0 && core_id < parent_pe_->num_cores_) {
        return core_utilization_history_[core_id];
    }
    return 0.0;
}

double MultiCoreController::getOverallUtilization() const {
    if (parent_pe_->num_cores_ == 0) return 0.0;
    
    double total_util = 0.0;
    for (int i = 0; i < parent_pe_->num_cores_; i++) {
        total_util += core_utilization_history_[i];
    }
    
    return total_util / parent_pe_->num_cores_;
}

void MultiCoreController::redistributeWork() {
    // ç®€åŒ–çš„å·¥ä½œé‡åˆ†å¸ƒç­–ç•¥
    // å®é™…å®ç°ä¸­å¯èƒ½éœ€è¦è¿ç§»è„‰å†²é˜Ÿåˆ—æˆ–è°ƒæ•´æƒé‡åˆ†å¸ƒ
    
    int most_loaded = findMostLoadedCore();
    int least_loaded = findLeastLoadedCore();
    
    if (most_loaded >= 0 && least_loaded >= 0 && most_loaded != least_loaded) {
        // å°†ä¸€äº›å·¥ä½œä»æœ€ç¹å¿™çš„æ ¸å¿ƒè½¬ç§»åˆ°æœ€ç©ºé—²çš„æ ¸å¿ƒ
        uint64_t work_to_transfer = core_work_count_[most_loaded] / 10;  // è½¬ç§»10%çš„å·¥ä½œ
        
        core_work_count_[most_loaded] -= work_to_transfer;
        core_work_count_[least_loaded] += work_to_transfer;
        
        output_->verbose(CALL_INFO, 4, 0, "ğŸ“‹ å·¥ä½œé‡åˆ†å¸ƒ: æ ¸å¿ƒ%d -> æ ¸å¿ƒ%d (è½¬ç§»%" PRIu64 "ä¸ªå·¥ä½œå•å…ƒ)\n",
                        most_loaded, least_loaded, work_to_transfer);
    }
}

int MultiCoreController::findLeastLoadedCore() const {
    int least_loaded = 0;
    double min_utilization = core_utilization_history_[0];
    
    for (int i = 1; i < parent_pe_->num_cores_; i++) {
        if (core_utilization_history_[i] < min_utilization) {
            min_utilization = core_utilization_history_[i];
            least_loaded = i;
        }
    }
    
    return least_loaded;
}

int MultiCoreController::findMostLoadedCore() const {
    int most_loaded = 0;
    double max_utilization = core_utilization_history_[0];
    
    for (int i = 1; i < parent_pe_->num_cores_; i++) {
        if (core_utilization_history_[i] > max_utilization) {
            max_utilization = core_utilization_history_[i];
            most_loaded = i;
        }
    }
    
    return most_loaded;
}

// ===== å†…å­˜å“åº”å¤„ç† =====

void MultiCorePE::handleMemoryResponse(SST::Interfaces::StandardMem::Request* resp) {
    if (!resp) return;
    
    output_->verbose(CALL_INFO, 4, 0, "ğŸ“¨ æ”¶åˆ°å†…å­˜å“åº”: åœ°å€=0x%lx, å¤§å°=%zu\n", 
                    resp->getAddr(), resp->getSize());
    
    // æŸ¥æ‰¾å¯¹åº”çš„æŒ‚èµ·è¯·æ±‚
    auto it = pending_memory_requests_.find(resp->getID());
    if (it != pending_memory_requests_.end()) {
        SpikeEvent* original_spike = it->second;
        pending_memory_requests_.erase(it);
        
        // å¤„ç†åŸå§‹è„‰å†²äº‹ä»¶
        if (original_spike) {
            handleExternalSpike(original_spike);
        }
        
        stat_memory_requests_->addData(1);
    } else {
        output_->verbose(CALL_INFO, 2, 0, "âš ï¸ æœªæ‰¾åˆ°å¯¹åº”çš„æŒ‚èµ·å†…å­˜è¯·æ±‚: ID=%" PRIu64 "\n", resp->getID());
    }
    
    delete resp;
}
